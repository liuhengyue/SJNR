import tensorflow as tfimport numpy as npfrom model import Modelfrom PIL import Imageimport sys, osfrom fnmatch import fnmatchimport itertoolstf.app.flags.DEFINE_string('path', None, 'Path to image test folder')tf.app.flags.DEFINE_string('restore_checkpoint', None,                           'Path to restore checkpoint (without postfix), e.g. ./logs/train/model.ckpt-100')FLAGS = tf.app.flags.FLAGSdef main(_):    path = FLAGS.path    path_to_restore_checkpoint_file = FLAGS.restore_checkpoint    files = getTestFiles(path)    num = 0    correct = 0    for key in files:        print key        # print files['1']        class_num = len(files[key])        num = num + class_num        images = [tf.image.decode_jpeg(tf.read_file(image_dir), channels=3) for image_dir in files[key]]        # print images[0], images[1]        # image = tf.image.resize_image_with_crop_or_pad(image, 64, 64)        for i in range(0, len(files[key])):            im = Image.open(files[key][i])            width, height = im.size            images[i] = tf.image.crop_to_bounding_box(images[i], height / 4, width / 2 - 32, 64, 64)        # stack multiple images        images = tf.stack(images)        # image = tf.image.resize_images(image, [64, 64])        images = tf.reshape(images, [-1, 64, 64, 3])        images = tf.image.convert_image_dtype(images, dtype=tf.float32)        images = tf.multiply(tf.subtract(images, 0.5), 2)        images = tf.image.resize_images(images, [54, 54])        images = tf.reshape(images, [-1, 54, 54, 3])        # images = tf.unstack(images)        # print images        # for image in images:        length_logits, digits_logits = Model.inference(images, drop_rate=0.0)        length_predictions = tf.argmax(length_logits, axis=1)        digits_predictions = tf.argmax(digits_logits, axis=2)        digits_predictions_string = tf.reduce_join(tf.as_string(digits_predictions), axis=1)        with tf.Session() as sess:            restorer = tf.train.Saver()            restorer.restore(sess, path_to_restore_checkpoint_file)            length_predictions_val, digits_predictions_string_val = sess.run(                [length_predictions, digits_predictions_string])            # print 'length: ', length_predictions_val            # print 'digits: ', digits_predictions_string_val            predictions = [d[:l] for l, d in itertools.izip(length_predictions_val, digits_predictions_string_val)]            print predictions            class_correct = sum([1.0 for p in predictions if p == key])            correct = correct + class_correct            print 'Accuracy: ', class_correct / class_num    print '%d total Accuracy: %f' % (num, correct / num)# length_prediction_val = length_predictions_val[0]# digits_prediction_string_val = digits_predictions_string_val[0]# print 'length: %d' % length_prediction_val# print 'digits: %s' % digits_prediction_string_valdef display(images):    sess = tf.Session()    plt.imshow(np.asarray(images.eval(session=sess)))    plt.imshow(sess.run(images))    plt.show()def getTestFiles(root):    test_set = {}    subdirs = next(os.walk(root))[1]    for subdir in subdirs:        # print subdir        path = os.path.join(root, subdir)        # print path        subfiles = [os.path.join(path, name) for name in next(os.walk(path))[2] if fnmatch(name, "*.png")]        test_set[subdir] = subfiles    return test_setif __name__ == '__main__':    tf.app.run(main=main)